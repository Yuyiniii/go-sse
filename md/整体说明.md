
# 通用高并发 SSE 平台与 Go 目录架构

目标
- 推送所有业务消息均可通过 SSE；支持 HTTP 发布和服务内直接调用
- Redis 作为消息“真相来源”，保证“至少一次投递”，断线可回放
- 高并发、低时延、可扩展，简化依赖

---

## 1) 详细流程图（订阅、回放、实时广播、发布）

说明
- 流程包含：客户端订阅、历史回放、实时广播、HTTP 发布、内部发布、断开清理
- 采用 Redis Streams 做持久化；Pub/Sub 做实时触发；Hub 做本机连接管理与非阻塞下发

```mermaid
flowchart LR
    subgraph Client["Client (EventSource)"]
        C1["GET /sse/stream?topics=...&cursors=..."]
        C2["接收历史回放事件"]
        C3["接收实时事件"]
        C4["接收 keepalive 心跳"]
        C5["断线重连（Last-Event-ID 或 cursors）"]
    end

    subgraph API["SSE 服务实例"]
        A0["HTTP Server"]
        A1["SSE Handler：解析 topics 与 cursors"]
        A2["历史回放：按 topic XRANGE/XREAD 补发"]
        A3["注册订阅：Hub.SubscribeMany(topics)"]
        A4["事件循环：从 Hub 取消息写 SSE"]
        A5["心跳：每 15s 写 ': keepalive'"]
        A6["断线清理：Hub.UnsubscribeMany"]
    end

    subgraph Hub["Hub（分片订阅表、非阻塞广播）"]
        H1["分片：fnv32(topic) % N"]
        H2["subs：map[topic] → set[client]"]
        H3["Broadcast：try send；满则剔除慢客户端"]
    end

    subgraph Redis["Redis"]
        R1["Streams：sse:stream:{topic}"]
        R2["Pub/Sub：sse:pub:{topic}"]
    end

    subgraph PubHTTP["发布入口（HTTP）"]
        P1["POST /api/publish"]
        P2["XADD sse:stream:{topic} → id"]
        P3["封装 envelope(topic,id,payload,ts)"]
        P4["PUBLISH sse:pub:{topic} envelope"]
        P5["返回 200 {id}"]
    end

    subgraph PubSDK["发布入口（内部调用）"]
        S1["Publish(ctx, topic, payload, opts)"]
        S2["XADD → id"]
        S3["PUBLISH envelope"]
    end

%% 连接关系（不加边标签，先保证可渲染）
    C1 --> A0 --> A1 --> A2 --> C2 --> A3 --> A4 --> C3
    A5 --> C4
    A4 --> A6 --> C5

    P1 --> P2 --> P3 --> P4 --> P5
    S1 --> S2 --> S3

    P4 --> A0
    S3 --> A0
    A0 --> H3 --> H2
    H3 --> A4

    A2 --> R1
    P2 --> R1
    S2 --> R1
```

要点
- 回放与实时并存：先回放，再订阅实时；避免回放窗口内的消息漏送
- 非阻塞广播：慢客户端直接剔除，保护整体时延
- 断线重连：客户端带 `Last-Event-ID`（单 topic）或 `cursors`（多 topic）从 “id 大于游标” 处补发

---

## 2) 类图（含设计模式）

说明
- 采用端口-适配器（Hexagonal）组织：核心依赖接口，Redis 作为适配器
- 使用多种设计模式：Observer、Strategy、Decorator、Factory、Template Method、Adapter

```mermaid

classDiagram
    direction LR

    class SSEServer {
        +Start()
        +Stop()
        -handler: SSEHandler
        -pubHandler: PublishHandler
        -pump: PubSubPump
    }
    note for SSEServer "应用组装入口：启动 HTTP、注册路由、启动 Pub/Sub 泵等；负责进程生命周期管理与依赖注入。"

    class SSEHandler {
        +HandleStream(req,res)
        -hub: Hub
        -streams: StreamRepo
        -notifier: Notifier
        -cursorStore: CursorStore
    }
SSEHandler : <<template method>>
note for SSEHandler "SSE 订阅入口：固定流程（回放 -> 订阅 -> 心跳 -> 循环写出）。容错与去重在此实现。使用 Template Method 模式。"

class PublishHandler {
+HandlePublish(req,res)
-publisher: Publisher
}
note for PublishHandler "HTTP 发布入口：解析请求、调用 Publisher 发布消息，返回消息 ID。"

class Publisher {
<<interface>>
+Publish(ctx, topic, payload, opts) id
}
note for Publisher "发布策略接口：可替换实现（Redis、MQ 等）。使用 Strategy 模式。"

class RedisPublisher {
+Publish(ctx, topic, payload, opts) id
-streams: StreamRepo
-notifier: Notifier
}
note for RedisPublisher "具体发布者：先 XADD 持久化，再 PUBLISH 实时触发。作为 Adapter 适配 Redis。"

class LoggingPublisher {
<<decorator>>
+Publish(ctx, topic, payload, opts) id
-next: Publisher
}
note for LoggingPublisher "发布日志装饰器：记录发布延迟、体积、错误等，对 Publisher 进行横切增强。Decorator 模式。"

class RateLimitPublisher {
<<decorator>>
+Publish(ctx, topic, payload, opts) id
-next: Publisher
-limiter: Limiter
}
note for RateLimitPublisher "发布限流装饰器：按 app/topic 做 QPS 控制，保护后端。Decorator 模式。"

class Limiter {
<<interface>>
+Allow(n) bool
}
note for Limiter "限流策略接口：可实现令牌桶、漏桶等不同算法。"

class TokenBucketLimiter {
+Allow(n) bool
}
TokenBucketLimiter ..|> Limiter
note for TokenBucketLimiter "令牌桶实现：以固定速率补充，支持突发。"

class StreamRepo {
<<interface>>
+Add(ctx, topic, payload, maxLen) id
+Range(ctx, topic, startID, count) []Envelope
}
note for StreamRepo "Streams 访问接口：持久化与回放的抽象，便于切换 Redis/MySQL/Kafka。Strategy 模式。"

class RedisStreamRepo {
+Add(...)
+Range(...)
}
RedisStreamRepo ..|> StreamRepo
note for RedisStreamRepo "Redis Streams 适配器：XADD/XRANGE 等，支持 MAXLEN 修剪。Adapter 模式。"

class Notifier {
<<interface>>
+Publish(ctx, topic, envelope)
+PSubscribe(ctx, pattern) <-chan Envelope
}
note for Notifier "通知接口：负责实时广播订阅与发布，抽象 Pub/Sub 能力。Strategy 模式。"

class RedisNotifier {
+Publish(...)
+PSubscribe(pattern)
}
RedisNotifier ..|> Notifier
note for RedisNotifier "Redis Pub/Sub 适配器：PUBLISH 与 PSUBSCRIBE sse:pub:*。Adapter 模式。"

class PubSubPump {
+Start()
-notifier: Notifier
-hub: Hub
}
note for PubSubPump "消息泵：从 Notifier 订阅 envelope，投递至 Hub 广播。实现进程内的 Observer 推送链路。"

class Hub {
<<interface>>
+SubscribeMany(topics) Client
+UnsubscribeMany(topics, c)
+Broadcast(topic, payload)
}
note for Hub "连接中枢接口：管理订阅集合并负责广播。作为被观察者（Subject）在 Observer 模式中。"

class ShardedHub {
+SubscribeMany(...)
+UnsubscribeMany(...)
+Broadcast(...)
-shards: Shard[]
}
ShardedHub ..|> Hub
note for ShardedHub "分片 Hub 实现：按 topic 取模分片，非阻塞 try-send；慢消费者剔除，保障整体时延与稳定性。"

class Shard {
-subs: map~string~ set~Client~
}
ShardedHub o-- Shard
note for Shard "每个分片维护 topic -> 客户端集合的订阅表；细粒度锁与垃圾回收。"

class Client {
-ch: chan []byte
-closed: atomicBool
+Close()
}
Shard o-- Client
note for Client "单个 SSE 连接的写通道与状态；通道满视为慢消费者并清理。作为 Observer。"

class SSEWriter {
+WriteEvent(id, event, data)
+WriteHeartbeat()
}
note for SSEWriter "SSE 写出工具：统一格式化 id/event/data 与心跳，保证刷写与错误处理。"

class Envelope {
+topic: string
+id: string
+ts: int64
+key: string
+payload: json
}
note for Envelope "消息载体：统一的跨层协议，含 topic、全局 ID、时间戳与业务负载。"

class EnvelopeFactory {
+New(topic, id, payload, ts, key) Envelope
}
EnvelopeFactory --> Envelope
note for EnvelopeFactory "工厂：集中构造 Envelope，确保字段完整与一致。Factory 模式。"

class CursorStore {
<<interface>>
+Get(clientID, topic) id
+Set(clientID, topic, id)
}
note for CursorStore "游标存储接口：可选，用于跨重连/跨设备记忆 lastID，增强去重与续传体验。"

class InMemoryCursorStore {
+Get(...)
+Set(...)
}
InMemoryCursorStore ..|> CursorStore
note for InMemoryCursorStore "内存实现：开发/单机调试用；生产可替换为 Redis/DB 实现。"

%% 关系（依赖/实现）
SSEServer --> SSEHandler
SSEServer --> PublishHandler
SSEServer --> PubSubPump

SSEHandler --> Hub
SSEHandler --> StreamRepo
SSEHandler --> Notifier
SSEHandler --> CursorStore
SSEHandler --> SSEWriter

PublishHandler --> Publisher

RedisPublisher ..|> Publisher
LoggingPublisher ..|> Publisher
RateLimitPublisher ..|> Publisher
LoggingPublisher --> Publisher
RateLimitPublisher --> Limiter
RateLimitPublisher --> Publisher

RedisStreamRepo ..|> StreamRepo
RedisNotifier ..|> Notifier

PubSubPump --> Notifier
PubSubPump --> Hub

Hub <.. Client
Client --> SSEWriter

```

设计模式标注
- Observer：`Hub` 作为主题，`Client` 作为观察者，`Broadcast` 通知
- Strategy：`StreamRepo` 与 `Notifier` 为可替换策略（Redis 实现、未来可换 MySQL/Kafka）
- Decorator：`LoggingPublisher`、`RateLimitPublisher` 装饰 `Publisher` 增加日志与限流
- Template Method：`SSEHandler.HandleStream` 固化“回放→订阅→心跳→循环”步骤
- Factory：`EnvelopeFactory` 统一封装消息格式
- Adapter：`RedisStreamRepo`、`RedisNotifier` 适配 Redis API

---

## 3) Go 目录架构（可落地）

目录树
```
sse-platform/
├─ cmd/
│  └─ sse-server/
│     └─ main.go                    # 组装依赖，启动 HTTP、Pub/Sub 泵
├─ internal/
│  ├─ api/
│  │  └─ http/
│  │     ├─ routes.go               # 注册路由
│  │     ├─ sse_handler.go          # SSE 订阅(回放+实时)
│  │     └─ publish_handler.go      # HTTP 发布
│  ├─ app/
│  │  ├─ sse/
│  │  │  ├─ service.go              # Template Method: HandleStream 流程
│  │  │  └─ cursors.go              # 游标解析、Last-Event-ID 支持
│  │  └─ publish/
│  │     ├─ service.go              # Publisher 组合与装饰
│  │     └─ options.go              # 发布选项(Trim MaxLen 等)
│  ├─ domain/
│  │  ├─ envelope.go                # Envelope 定义与工厂
│  │  └─ errors.go
│  ├─ ports/
│  │  ├─ hub.go                     # Hub 接口
│  │  ├─ notifier.go                # Notifier 接口
│  │  ├─ streams.go                 # StreamRepo 接口
│  │  ├─ publisher.go               # Publisher 接口
│  │  └─ cursor_store.go            # 可选：持久化游标接口
│  ├─ adapters/
│  │  ├─ hub/
│  │  │  ├─ sharded_hub.go         # 分片 Hub 实现
│  │  │  └─ client.go
│  │  └─ redis/
│  │     ├─ streams_repo.go         # XADD/XRANGE/XREAD 实现
│  │     ├─ notifier.go             # (P)SUBSCRIBE / PUBLISH
│  │     └─ pubsub_pump.go          # PSUBSCRIBE sse:pub:* -> Hub.Broadcast
│  ├─ pkg/
│  │  ├─ logger/
│  │  │  └─ logger.go
│  │  ├─ id/
│  │  │  └─ id.go                   # 请求/连接 ID
│  │  ├─ rate/
│  │  │  └─ limiter.go              # 发布限流(可选)
│  │  ├─ retry/
│  │  │  └─ retry.go                # 发布重试(可选)
│  │  └─ config/
│  │     └─ config.go               # 读取 env/yaml
│  └─ bootstrap/
│     └─ wire.go                    # 依赖注入组装（可选）
├─ configs/
│  └─ config.yaml                   # Redis 地址、分片数、心跳周期、Streams MaxLen
├─ scripts/
│  ├─ run_local.sh
│  └─ load_test_sse.js              # 简易压测脚本
└─ go.mod
```
